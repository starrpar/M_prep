package mprep;

public class StringMethods {

    // EASY:
    // 1.1 Remove Vowels from a String
    // Text guide (GeeksforGeeks)
    // Video guide (Kevin Naughton Jr.)
    // 1.2 Defanging an IP Address
    // Text guide (GeeksforGeeks)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 1.3 Jewels and Stones
    // Text guide (Memogrocery)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 1.4 Shuffle String
    // Text guide (Medium/RKP)
    // Video guide (Knowledge Mavens)
    // Code example (LeetCode)
    // 1.5 Split a String in Balanced Strings
    // Text guide (GeeksForGeeks)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 1.6 To Lower Case
    // Text guide (Dev.to/Seanpgallivan)
    // Video guide (Nick White)
    // Code example (LeetCode)
    // 1.7 Unique Morse Code Words
    // Text guide (Memogrocery)
    // Video guide (Nick White)
    // Code example (LeetCode)
    // 1.8 Count Substrings with Only One Distinct Letter
    // Text guide (HelloACM)
    // Video guide (GeeksForGeeks)
    // 1.9 Robot Return to Origin
    // Text guide (LeetCode)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 1.10 Fizz Buzz
    // Text guide (ITNext/Kevin)
    // Video guide (Tom Scott)
    // Code example (LeetCode)
    // 1.11 First Unique Character in a String
    // Text guide (AfterAcademy)
    // Video guide (Nick White)
    // Code example (LeetCode)
    // 1.12 Reverse String
    // Text guide (GeeksForGeeks)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 1.13 Valid Anagram
    // Text guide (Dev.to/Seanpgallivan)
    // Video guide (Terrible Whiteboard)
    // Code example (LeetCode)
    // 1.14 Valid Palindrome
    // Text guide (Medium/Urfan)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 1.15 Implement Strstr()
    // Text guide (RedQuark)
    // Video guide (Amell Peralta)
    // Code example (LeetCode)
    // 1.16 Valid Parentheses
    // Text guide (GeeksForGeeks)
    // Video guide (Back to Back SWE)
    // Code example (LeetCode)
    // 1.17 Roman to Integer
    // Text guide (Dev.to/Seanpgallivan)
    // Video guide (Thecodingworld)
    // Code example (LeetCode)
    // 1.18 Longest Common Prefix
    // Text guide (AfterAcademy)
    // Video guide (Nick White)
    // Code example (LeetCode)
    // 1.19 Excel Sheet Column Number
    // Text guide (AfterAcademy)
    // Video guide (Knowledge Center)
    // Code example (LeetCode)
    // 1.20 Palindrome Permutation
    // Text guide (Memogrocery)
    // Video guide (Knowledge Center)

    // MEDIUM:
    // 2.1 Longest Substring Without Repeating Characters
    // Text guide (Medium/Nerd For Tech)
    // Video guide (Michael Muinos)
    // Code example (LeetCode)
    // 2.2 Longest Palindromic Substring
    // Text guide (RedQuark)
    // Video guide (NeetCode)
    // Video guide (Errichto)
    // 2.3 String to Integer (atoi)
    // Text guide (Medium/Hary)
    // Video guide (TECH DOSE)
    // Code example (LeetCode)
    // 2.4 Letter Combinations of a Phone Number
    // Text guide (Dev.to/Seanpgallivan)
    // Video guide (Kevin Naughton Jr.)
    // 2.5 Generate Parentheses
    // Text guide (RedQuark)
    // Video guide (Back to Back SWE)
    // Code example (LeetCode)
    // 2.6 Count and Say
    // Text guide (GeeksforGeeks)
    // Video guide (Terrible Whiteboard)
    // Code example (LeetCode)
    // 2.7 Group Anagrams
    // Text guide (Techie Delight)
    // Video guide (Nick White)
    // 2.8 Decode Ways
    // Text guide (Toronto CS)
    // Video guide (CS Dojo)
    // Video guide (Back to Back SWE)
    // 2.9 Palindrome Partitioning
    // Text guide (GeeksforGeeks)
    // Video guide (NeetCode)
    // 2.10 Word Break
    // Text guide (ProgrammerSought)
    // Video guide (Happygirlzt)
    // Video guide (NeetCode)
    // 2.11 Fraction to Recurring Decimal
    // Text guide (ProgrammerSought)
    // Video guide (Happygirlzt)
    // Code example (LeetCode)
    // 2.12 Largest Number
    // Text guide (Easy Explanations)
    // Video guide (Jayati Tiwari)
    // Code example (LeetCode)
    // 2.13 Implement Trie (Prefix Tree)
    // Text guide (Medium/Saurav)
    // Video guide (NeetCode)
    // Code example (LeetCode)
    // 2.14 Basic Calculator II
    // Text guide (Medium/Calvin)
    // Video guide (Happygirlzt)
    // Code example (LeetCode)
    // 2.15 Longest Substring with At Least K Repeating Characters
    // Text guide (GeeksforGeeks)
    // Video guide (Knowledge Center)
    // Code example (LeetCode)
    // 2.16 Palindrome Partitioning
    // Text guide (LeetCode)
    // Video guide (BacktoBackSWE)
    // Code example (LeetCode)
    // 2.17 Reorganize String
    // Text guide (GeeksforGeeks)
    // Video guide (Kevin Naughton Jr.)
    // Code example (LeetCode)
    // 2.18 ZigZag Conversion
    // Text guide (RedQuark)
    // Video guide (Google Engineer Explains)
    // Code example (LeetCode)
    // 2.19 Decode String
    // Text guide (Medium/Signal Cat)
    // Video guide (Nick White)
    // Code example (LeetCode)
    // 2.20 Multiply Strings
    // Text guide (Medium/Nikhil Anand)
    // Video guide (NeetCode)
    // Code example (LeetCode)

    // HARD:
    // 3.1 Regular Expression Matching
    // Text guide (RedQuark)
    // Video guide (NeetCode)
    // Code example (LeetCode)
    // 3.2 Wildcard Matching
    // Text guide (Techie Delight)
    // Video guide (Tushar Roy)
    // Code example (LeetCode)
    // 3.3 Minimum Window Substring
    // Text guide (Medium/Algo Shaft)
    // Video guide (Back to Back SWE)
    // Code example (LeetCode)
    // 3.4 Word Ladder
    // Text guide (GeeksforGeeks)
    // Video guide (Nick White)
    // Code example (LeetCode)
    // 3.5 Word Break II
    // Text guide (Educative)
    // Video guide (Babybear4812)
    // Code example (LeetCode)
    // 3.6 Word Search II
    // Text guide (Medium/Hary)
    // Video guide (Timothy H Chang)
    // Code example (LeetCode)
    // 3.7 Serialize and Deserialize Binary Tree
    // Text guide (Dev.to/Akhilpolke)
    // Video guide (BacktoBack SWE)
    // Code example (LeetCode)
    // 3.8 Longest Valid Parentheses
    // Text guide (Dev.to/Seanpgallivan)
    // Video guide (Algorithms Made Easy)
    // Code example (LeetCode)
    // 3.9 Edit Distance
    // Text guide (GeeksforGeeks)
    // Video guide (NeetCode)
    // Code example (LeetCode)
    // 3.10 Alien Dictionary (string/graph)
    // Text guide (Medium/Timothy)
    // Video guide (Happygirlzt)
    // Video guide (NeetCode)
    // 3.11 Design Search Autocomplete System
    // Video guide (Happygirlzt)
    // Video guide (Babybear4812)
    // Code example (Cheonhyangzhang)

    // Valid Palindrome
    // Given a non-empty string s, you may delete at most one character. Judge
    // whether you can make it a palindrome.
    // Given a string s, return true if the s can be palindrome after deleting at
    // most one character from it.

    // Example 1:

    // Input: s = "aba"
    // Output: true
    // Example 2:

    // Input: s = "abca"
    // Output: true
    // Explanation: You could delete the character 'c'.
    // Example 3:

    // Input: s = "abc"
    // Output: false

    // Constraints:

    // 1 <= s.length <= 105
    // s consists of lowercase English letters.

    boolean isPalindrome1(String s) {
        String tempStr = s.toLowerCase().replaceAll("\\s", "").replaceAll(",", "");

        char[] cArr = tempStr.toCharArray();

        for (int i = 0; i < tempStr.length(); i++) {
            if (cArr[i] != cArr[(tempStr.length() - 1) - i]) {
                return false;
            }
        }
        return true;
    }

    boolean isPalindrome2(String s) {
        // put all characters into a Hashmap (or List<KeyValuePair> ) with character as
        // key and count as value

        // determine if there is an "odd count" for any chars; if so, determine if that
        // is for a character in the exact middle of the palindrome - a palindrome can
        // have an unmatched char as the middle character if it is an odd number of
        // characters
        // possible scenarios:
        //
        // LOGIC:
        // - no odd number of characters
        // - test for palindrome; if not pass, could never be one with removal of a
        // single char
        // - above is not true - could have an odd-numbered string with one char as the
        // middle
        // char and an additional entry somewhere (making it have an even number of that
        // char)
        // elsewhere in the string, which would then make its removal create a
        // palindrome
        // - so above is only valid if current string is odd-numbered length; will need
        // a
        // different strategy for even numbered string length; possibly verify first if
        // the
        // "two center" chars are the same, in which case, is likely either the string
        // is
        // already a palindrome, and also would be if removal of one of those middle 2
        // chars
        // was done, because the other remaining char of the same character would be the
        // middle char in a now-odd-numbered string which is a palindrome (or could be
        // tested
        // for being one)
        // - the only other case for that is if it is an even-numbered string length,
        // and the two
        // chars at the center were NOT the same latter, then determining what the
        // "middle 4"
        // were would indicate which one was the "actual center" (if it's going to be a
        // palindrome and either letters 1 and 3 or letters 2 and 4 would match). The
        // task then would be to find the location of the other occurrence of whatever
        // letter
        // is in the "actual middle" (determined using logic just above), or the "odd
        // one out"
        // if there are multiple other occurrences of the same letter in the string.
        // - one odd number of char
        // - determine if string has an odd number of chars, and if so, if that char
        // that has
        // an odd number of occurrences is the middle char; test for palindrome if so
        // - multiple odd number chars (if more than two, then won't be palindrome with
        // removal of one)
        // - only two odd number of char occurrences
        // - identify if one or other is middle char of string
        // - look for occurrence of other char, remove it, and test for palindrome

        String tempStr = s.toLowerCase().replaceAll("\\s", "").replaceAll(",", "");
        int sLen = tempStr.length();
        char[] cArr = tempStr.toCharArray();
        boolean notMatching = false;
        boolean possible = false;
        boolean first = false;
        boolean nonMatchingNotYetConveyed = true;
        boolean typeAlreadyFound = false;

        for (int i = 0; i < sLen; i++) {
            System.out.print(cArr[i]);
        }
        for (int i = 0; i < sLen; i++) {
            int reversei = (sLen - 1) - i;
            System.out.print("\n(i0): " + i + ", " + (sLen - 1 - i));
            System.out.print("\n");
            for (int j = 0; j < cArr.length; j++) {
                System.out.print(cArr[j]);
            }
            possible = false;
            if (cArr[i] == cArr[reversei]) {
                System.out.println("\nMatching (i): " + i + ", " + cArr[i] + ":" + cArr[(sLen - 1) - i]);
                continue;
            } else if (cArr[i + 1] == cArr[reversei] && !typeAlreadyFound) {
                System.out.print("\n1typeFound: " + typeAlreadyFound);
                System.out.println("\nNot matching (i): " + i + ", " + cArr[i] + ":" + cArr[(sLen - 1) - i]);
                if (nonMatchingNotYetConveyed) {
                    System.out.println("\nNon-matching char: " + cArr[i]);
                    nonMatchingNotYetConveyed = false;
                }
                System.out.print("\n(i1): " + i + ", " + (sLen - 1 - i));
                for (int j = i; j < sLen - 1; j++) {
                    System.out.println("\n***************************************");
                    System.out.print("\n1Replacing: " + cArr[j] + " with " + cArr[j + 1]);
                    cArr[j] = cArr[j + 1];
                }
                cArr[sLen - 1] = '\0';
                System.out.print("\n");
                for (int j = 0; j < cArr.length; j++) {
                    System.out.print(cArr[j]);
                }
                reversei++;
                sLen--;
                typeAlreadyFound = true;
            } else if (cArr[i] == cArr[reversei - 1] && !typeAlreadyFound) {
                System.out.print("\n2typeFound: " + typeAlreadyFound);
                System.out.println("\nNot matching (i): " + i + ", " + cArr[i] + ":" + cArr[(sLen - 1) - i]);
                for (int j = 0; j < cArr.length; j++) {
                    System.out.print(j + ": " + cArr[j] + ", ");
                }
                if (nonMatchingNotYetConveyed) {
                    System.out.println("\n***************************************");
                    System.out.println("\nNon-matching char: " + cArr[(sLen - 1) - i]);
                    nonMatchingNotYetConveyed = false;
                }
                System.out.print("\n(i2): " + i + ", " + (sLen - 1 - i));
                for (int j = (sLen - 1) - i; j < sLen - 1; j++) {
                    System.out.print("\n2Replacing: " + cArr[j] + " with " + cArr[j + 1]);
                    cArr[j] = cArr[j + 1];
                    System.out.print("\n:" + reversei + ", " + sLen);
                }
                cArr[sLen - 1] = '\0';
                System.out.print("\n");
                for (int j = 0; j < cArr.length; j++) {
                    System.out.print(cArr[j]);
                }
                reversei--;
                sLen--;
                typeAlreadyFound = true;
                System.out.print("\n:" + reversei + ", " + sLen);
            } else {
                notMatching = true;
            }
        }

        return !notMatching;
    }

    boolean isPalindrome3(String s) {

        // this version can adjust for multiple typos and still find a palindrome

        String tempStr = s.toLowerCase().replaceAll("\\s", "").replaceAll(",", "");
        int sLen = tempStr.length();
        char[] cArr = tempStr.toCharArray();
        boolean notMatching = false;
        boolean possible = false;
        boolean first = false;
        boolean nonMatchingNotYetConveyed = true;

        for (int i = 0; i < sLen; i++) {
            System.out.print(cArr[i]);
        }
        for (int i = 0; i < sLen; i++) {
            int reversei = (sLen - 1) - i;
            System.out.print("\n(i0): " + i + ", " + (sLen - 1 - i));
            System.out.print("\n");
            for (int j = 0; j < cArr.length; j++) {
                System.out.print(cArr[j]);
            }
            possible = false;
            if (cArr[i] == cArr[reversei]) {
                System.out.println("\nMatching (i): " + i + ", " + cArr[i] + ":" + cArr[(sLen - 1) - i]);
                continue;
            } else if (cArr[i + 1] == cArr[reversei]) {
                System.out.println("\nNot matching (i): " + i + ", " + cArr[i] + ":" + cArr[(sLen - 1) - i]);
                if (nonMatchingNotYetConveyed) {
                    System.out.println("\nNon-matching char: " + cArr[i]);
                    nonMatchingNotYetConveyed = false;
                }
                System.out.print("\n(i1): " + i + ", " + (sLen - 1 - i));
                for (int j = i; j < sLen - 1; j++) {
                    System.out.println("\n***************************************");
                    System.out.print("\n1Replacing: " + cArr[j] + " with " + cArr[j + 1]);
                    cArr[j] = cArr[j + 1];
                }
                cArr[sLen - 1] = '\0';
                System.out.print("\n");
                for (int j = 0; j < cArr.length; j++) {
                    System.out.print(cArr[j]);
                }
                reversei++;
                sLen--;
            } else if (cArr[i] == cArr[reversei - 1]) {
                System.out.println("\nNot matching (i): " + i + ", " + cArr[i] + ":" + cArr[(sLen - 1) - i]);
                for (int j = 0; j < cArr.length; j++) {
                    System.out.print(j + ": " + cArr[j] + ", ");
                }
                if (nonMatchingNotYetConveyed) {
                    System.out.println("\n***************************************");
                    System.out.println("\nNon-matching char: " + cArr[(sLen - 1) - i]);
                    nonMatchingNotYetConveyed = false;
                }
                System.out.print("\n(i2): " + i + ", " + (sLen - 1 - i));
                for (int j = (sLen - 1) - i; j < sLen - 1; j++) {
                    System.out.print("\n2Replacing: " + cArr[j] + " with " + cArr[j + 1]);
                    cArr[j] = cArr[j + 1];
                    System.out.print("\n:" + reversei + ", " + sLen);
                }
                cArr[sLen - 1] = '\0';
                System.out.print("\n");
                for (int j = 0; j < cArr.length; j++) {
                    System.out.print(cArr[j]);
                }
                reversei--;
                sLen--;

                System.out.print("\n:" + reversei + ", " + sLen);
            } else {
                notMatching = true;
            }
        }

        return !notMatching;
    }

    // Minimum window substring
    // Given a string S and a string T, find the minimum window in S which will
    // contain all the characters in T in complexity O(n).
    // Given two strings s and t of lengths m and n respectively, return the minimum
    // window
    // substring
    // of s such that every character in t (including duplicates) is included in the
    // window. If there is no such substring, return the empty string "".

    // The testcases will be generated such that the answer is unique.

    // Example 1:

    // Input: s = "ADOBECODEBANC", t = "ABC"
    // Output: "BANC"
    // Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C'
    // from string t.
    // Example 2:

    // Input: s = "a", t = "a"
    // Output: "a"
    // Explanation: The entire string s is the minimum window.
    // Example 3:

    // Input: s = "a", t = "aa"
    // Output: ""
    // Explanation: Both 'a's from t must be included in the window.
    // Since the largest window of s only has one 'a', return empty string.

    // Constraints:

    // m == s.length
    // n == t.length
    // 1 <= m, n <= 105
    // s and t consist of uppercase and lowercase English letters.

    // Follow up: Could you find an algorithm that runs in O(m + n) time?

}
